// timer_cam_PWCmode.cpp : Defines the entry point for the console application.
//
// Timing and synchronization program for use in DPIV/T data acquisition
// Master clock for the acquisition system is generated by a NI PCI-6602 timing card
// All timing signals are synchronized to this clock, including triggering of the camera
// makes use the of the NI-DAQmx drivers using ANSI C support
// 
// PCI-6602 must be connected to the modified NI SCB-68 breakout card mounted in the CA-1000 enclosure
// Camera should run in synchronous accumulation mode where an exposure can start while the previous image data is being read-out but should not end before read-out is complete 
//
// written by Prabu Sellappan, 06/27/2012. Based on timer_camslave written by TP.
//

#include "stdafx.h"

void main(void)
{

	/* DECLARATIONS */
	
	//misc
	TaskHandle handle;
	int32 status;
	char junk[100];

	//timebase
	//using onboard 80Mhz clock
	char TimebaseTerm[20] = "/Dev1/80MHzTimebase";
	char TimebaseString[16] = "80MHz Clock";
	float64 TimebaseFreq = 80.0e6;
	float64 TimebasePer = 1.0/TimebaseFreq; // 12.5e-9;

	// Pulse Timing
    float64 dFreq,Freq;
	float64 period;
	float64 PulseSep,FLtoQS,FLwidth,QSwidth;
	int32 SingleFrame, DoubleFrame, LowCounts, HighCounts;
	int32 DeltaT, FL1delay, FL2delay, FLhigh, FLlow, QS1delay, QS2delay, QShigh,QSlow, FLtoQScounts;
	int32 SkewCorrect = 490; //increment of correction in initial delay duration to correct for offsets in channel start times

	/* IMPLEMENTATION BEGINS HERE */

	//reset the device in case a previous task was left running
	status = DAQmxResetDevice ("Dev1");

	/* GET DESIRED TIMING PARAMETERS FROM USER AND CALCULATE ACTUAL TIMING PARAMETERS */

	// get frame rate from user and convert to counts; adjust period to whole counts as needed
	printf("\n timer_cam_PWCmode ");
	printf("\n Timing and synchronization program for use in DPIV/T data acquisition ");
	printf("\n written by Prabu Sellappan, 06/27/2012. Based on timer_camslave written by Tait Pottebaum. \n");
	printf("\nEnter frame rate (frequency) to generate [Hz]: ");
    scanf("%lf",&dFreq);
	period = 1.0/dFreq;
	SingleFrame = period*TimebaseFreq;
	period = TimebasePer*SingleFrame;
	Freq = 1.0/period;
	printf("Frame rate to be produced = %0.8f frames/sec\n\n",Freq);
	printf("Enter pulse separation (delta t) [microseconds]: ");
	scanf("%lf",&PulseSep);
	//require pulse separation to be longer than 500 microseconds. This value is arbitrary.
	//It is longer than the minimum time required between trigger pulses for most cameras. Modify it based on camera specs  
	while (PulseSep<=500) 
	{
		printf("Pulse separation must ge greater than 500 microseconds.\nRe-enter: ");
		scanf("%lf",&PulseSep);
	}

	// get remaining timing parameters
	printf("Enter Flashlamp to Q-Switch delay from laser specifications (usually 190) [microseconds]: ");
	scanf("%lf",&FLtoQS);
	printf("Enter Flashlamp pulse width from laser specifications [microseconds]: "); 
	scanf("%lf",&FLwidth);
	printf("Enter Q-Switch pulse width from laser/white-light source(if unavailable, use 110) specifications [microseconds]: "); 
	scanf("%lf",&QSwidth);

	// calculate the high, low and initial delays for each pulse train in counts
	DeltaT = ceil(PulseSep*1.0e-6*TimebaseFreq);
	PulseSep = DeltaT*TimebasePer;
	FLtoQScounts = ceil(FLtoQS*1.0e-6*TimebaseFreq);
	FLhigh = ceil(FLwidth*1.0e-6*TimebaseFreq);
	QShigh = ceil(QSwidth*1.0e-6*TimebaseFreq);

	LowCounts = DeltaT - FLtoQScounts - FLhigh - QShigh - ceil(325*1.0e-6*TimebaseFreq);
	HighCounts = SingleFrame - LowCounts;
	DoubleFrame = 2*SingleFrame;

	// calculate the various times in counts
	FL1delay = (4*SkewCorrect) + SingleFrame + (HighCounts - QShigh - ceil(225*1.0e-6*TimebaseFreq) - FLtoQScounts - FLhigh);
	FL2delay = FL1delay + DeltaT;
	FLlow = DoubleFrame - FLhigh;
	QS1delay = FL1delay + FLtoQScounts;
	QS2delay = FL2delay + FLtoQScounts;
	QSlow = DoubleFrame - QShigh;
	printf("FL1 delay = %i counts\n",FL1delay);
	printf("QS1 delay = %i counts\n",QS1delay);
	printf("FL2 delay = %i counts\n",FL2delay);
	printf("QS2 delay = %i counts\n",QS2delay);

	printf("\n\nMake sure to use the GENERATED pulse separation for DPIV processing.\n");
	printf("GENERATED pulse separation = %0.4f microseconds.\n",PulseSep*1.0e6);
	printf("\nMake sure to use the GENERATED frame rate for analyzing data.\n");
	printf("GENERATED rate = %0.8f frames/sec.\n\n",Freq);

	/* SETUP AND START THE TASK TO RUN THE COUNTERS AND PRODUCE THE SIGNALS */

	//create the task for generating pulses
	status = DAQmxCreateTask ("CamSlavePulses", &handle);
	//printf("%i\n",status);

	//add the camera trigger or exposure enable pulse on counter 1 as a channel in the task
	//specify high (exposure on) and low (exposure off) durations as clock ticks
	//"initial delay" is a correction for the offset start times of the different channels
	status = DAQmxCreateCOPulseChanTicks(handle, "Dev1/ctr1", "CamTrig", TimebaseTerm, DAQmx_Val_Low, 4*SkewCorrect,LowCounts, HighCounts);
	//printf("%i\n",status);

	//add the Flashlamp 1 pulse on counter 2 as a channel in the task; all durations specified as clock ticks
	//"initial delay" is clock ticks from start of "A" frame to rising edge of FL1 pulse + a correction for the offset start times of the different channels
	//high time is FL1 pulse width
	//low time is (duration of 2 frames) - (FL1 pulse width) so that pulse train has same period as 2 frames
	status = DAQmxCreateCOPulseChanTicks (handle, "Dev1/ctr2", "FL1", TimebaseTerm, DAQmx_Val_Low, FL1delay+3*SkewCorrect, FLlow, FLhigh);
	//printf("%i\n",status);

	//add the Q-Switch 1 pulse on counter 3 as a channel in the task; all durations specified as clock ticks
	//"initial delay" is clock ticks from start of "A" frame to rising edge of QS1 pulse + a correction for the offset start times of the different channels
	//high time is QS1 pulse width
	//low time is (duration of 2 frames) - (QS1 pulse width) so that pulse train has same period as 2 frames
	status = DAQmxCreateCOPulseChanTicks (handle, "Dev1/ctr3", "QS1", TimebaseTerm, DAQmx_Val_Low, QS1delay+2*SkewCorrect, QSlow, QShigh);
	//printf("%i\n",status);

	//add the Flashlamp 2 pulse on counter 4 as a channel in the task; all durations specified as clock ticks
	//"initial delay" is clock ticks from start of "A" frame to rising edge of FL2 pulse + a correction for the offset start times of the different channels
	//high time is FL2 pulse width
	//low time is (duration of 2 frames) - (FL2 pulse width) so that pulse train has same period as 2 frames
	status = DAQmxCreateCOPulseChanTicks (handle, "Dev1/ctr4", "FL2", TimebaseTerm, DAQmx_Val_Low, FL2delay+1*SkewCorrect, FLlow, FLhigh);
	//printf("%i\n",status);

	//add the Q-Switch 2 pulse on counter 5 as a channel in the task; all durations specified as clock ticks
	//"initial delay" is clock ticks from start of "A" frame to rising edge of QS2 pulse
	//high time is QS2 pulse width
	//low time is (duration of 2 frames) - (QS2 pulse width) so that pulse train has same period as 2 frames
	status = DAQmxCreateCOPulseChanTicks (handle, "Dev1/ctr5", "QS2", TimebaseTerm, DAQmx_Val_Low, QS2delay, QSlow, QShigh);
	//printf("%i\n",status);

	//configure the task for continuous pulse generation
	status = DAQmxCfgImplicitTiming (handle, DAQmx_Val_ContSamps, 0);
	//printf("%i\n",status);

	//start the task
	status = DAQmxStartTask (handle);
	//printf("%i\n",status);

	printf("Type anything then press Enter key to end program. \n");
	scanf("%s",&junk);
	//printf("%s\n",junk);

	//clear the task
	status = DAQmxClearTask (handle);
	//printf("%i\n",status);

	return;
}